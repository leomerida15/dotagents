/**
 * Build-time script: reads rules/*.yaml and generates WorkspaceAgents.generated.ts
 * with WORKSPACE_KNOWN_AGENTS. Run from apps/vscode (cwd = apps/vscode).
 */
import { readdir, readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import yaml from 'js-yaml';

interface PathEntry {
	path: string;
	scope?: 'workspace' | 'home';
	type?: 'file' | 'directory';
	purpose?: 'marker' | 'sync_source' | 'config';
}

interface YamlSchema {
	agent?: { id?: string; name?: string; source_root?: string; paths?: PathEntry[] };
	source_root?: string;
	paths?: PathEntry[];
}

const RULES_DIR = join(process.cwd(), '..', '..', 'rules');
const OUT_PATH = join(
	process.cwd(),
	'src',
	'modules',
	'orchestrator',
	'domain',
	'WorkspaceAgents.generated.ts',
);

function deriveWorkspaceMarker(paths: PathEntry[] | undefined, sourceRoot: string): string {
	if (paths != null && paths.length > 0) {
		const workspacePaths = paths.filter((p) => p.scope === 'workspace');
		const markerOrSync = workspacePaths.find(
			(p) => p.purpose === 'marker' || p.purpose === 'sync_source',
		);
		if (markerOrSync) return markerOrSync.path.replace(/\/$/, '');
		const first = workspacePaths[0];
		if (first) return first.path.replace(/\/$/, '');
	}
	return sourceRoot.replace(/\/$/, '');
}

function deriveConfigPath(paths: PathEntry[] | undefined, sourceRoot: string): string {
	if (paths != null && paths.length > 0) {
		const homeConfig = paths.find((p) => p.scope === 'home' && p.purpose === 'config');
		if (homeConfig) return homeConfig.path;
	}
	return sourceRoot.replace(/\/$/, '');
}

function pathEntryToLiteral(p: PathEntry): string {
	const parts = [
		`path: ${JSON.stringify(p.path)}`,
		p.scope != null ? `scope: ${JSON.stringify(p.scope)}` : null,
		p.type != null ? `type: ${JSON.stringify(p.type)}` : null,
		p.purpose != null ? `purpose: ${JSON.stringify(p.purpose)}` : null,
	].filter(Boolean);
	return `{ ${parts.join(', ')} }`;
}

function knownAgentToLiteral(agent: {
	id: string;
	configPath: string;
	workspaceMarker: string;
	paths?: PathEntry[];
}): string {
	const pathsLiteral =
		agent.paths != null && agent.paths.length > 0
			? `paths: [\n      ${agent.paths.map((p) => pathEntryToLiteral(p)).join(',\n      ')},\n    ]`
			: '';
	return `  {
    id: ${JSON.stringify(agent.id)},
    configPath: ${JSON.stringify(agent.configPath)},
    workspaceMarker: ${JSON.stringify(agent.workspaceMarker)},
${pathsLiteral ? `    ${pathsLiteral},\n` : ''}  }`;
}

async function main(): Promise<void> {
	let entries: { name: string }[];
	try {
		entries = (await readdir(RULES_DIR, { withFileTypes: true }))
			.filter((e) => e.isFile() && e.name.endsWith('.yaml'))
			.map((e) => ({ name: e.name }));
	} catch (err) {
		console.error('Failed to read rules dir:', RULES_DIR, err);
		process.exit(1);
	}

	const knownAgents: Array<{
		id: string;
		configPath: string;
		workspaceMarker: string;
		paths?: PathEntry[];
	}> = [];

	for (const { name } of entries) {
		const filePath = join(RULES_DIR, name);
		let content: string;
		try {
			content = await readFile(filePath, 'utf-8');
		} catch (err) {
			console.error('Failed to read:', filePath, err);
			process.exit(1);
		}
		let parsed: unknown;
		try {
			parsed = yaml.load(content);
		} catch (err) {
			console.error('Invalid YAML:', filePath, err);
			process.exit(1);
		}
		if (parsed == null || typeof parsed !== 'object') {
			console.error('Empty or invalid YAML:', filePath);
			process.exit(1);
		}
		const schema = parsed as YamlSchema;
		const agent = schema.agent;
		const id = agent?.id ?? (schema as { agent?: { id?: string } }).agent?.id;
		if (!id || typeof id !== 'string') {
			console.error('Invalid YAML: Missing agent.id in', filePath);
			process.exit(1);
		}
		const paths = agent?.paths ?? schema.paths;
		const sourceRootFromPaths =
			paths != null && paths.length > 0
				? (() => {
						const ws = paths.filter((p) => p.scope === 'workspace');
						const m = ws.find((p) => p.purpose === 'marker' || p.purpose === 'sync_source');
						return (m ?? ws[0])?.path;
					})()
				: null;
		const sourceRoot =
			sourceRootFromPaths ?? agent?.source_root ?? schema.source_root ?? '.';
		const workspaceMarker = deriveWorkspaceMarker(paths, sourceRoot);
		const configPath = deriveConfigPath(paths, sourceRoot);
		knownAgents.push({
			id,
			configPath,
			workspaceMarker,
			paths: paths ?? undefined,
		});
	}

	knownAgents.sort((a, b) => a.id.localeCompare(b.id));

	const lines = [
		'// Generated by scripts/generate-known-agents.ts â€” do not edit by hand',
		'',
		'export const WORKSPACE_KNOWN_AGENTS = [',
		knownAgents.map((a) => knownAgentToLiteral(a)).join(',\n'),
		'];',
		'',
	];
	await writeFile(OUT_PATH, lines.join('\n'), 'utf-8');
	console.log('Generated', OUT_PATH, 'with', knownAgents.length, 'agents');
}

main().catch((err) => {
	console.error(err);
	process.exit(1);
});
